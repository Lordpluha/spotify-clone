name: Production Deploy

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
      skip_tests:
        description: 'Skip tests'
        required: false
        type: boolean
        default: false

  push:
    branches:
      - main
    paths:
      - 'apps/**'
      - 'packages/**'

# Prevent concurrent deployments
concurrency:
  group: deploy-${{ github.event.inputs.environment || 'production' }}
  cancel-in-progress: false

env:
  DEPLOY_ENV: ${{ github.event.inputs.environment || 'production' }}

jobs:
  # Pre-deployment validation
  validate:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || 'production' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Validate docker-compose files
        run: |
          docker-compose -f docker-compose.prod.yaml config
          echo "‚úÖ Docker Compose configuration is valid"

      - name: Check required secrets
        env:
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          if [ -z "$SERVER_HOST" ] || [ -z "$SERVER_USER" ] || [ -z "$SSH_PRIVATE_KEY" ]; then
            echo "‚ùå Missing required secrets"
            exit 1
          fi
          echo "‚úÖ All required secrets are present"

  # Run tests before deploying
  tests:
    name: Run Tests
    runs-on: ubuntu-latest
    needs: validate
    if: github.event.inputs.skip_tests != 'true'
    timeout-minutes: 15

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_USER: test
          POSTGRES_DB: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 5432:5432

    steps:
      - uses: actions/checkout@v4

      - uses: pnpm/action-setup@v4
        with:
          version: 10.27.0

      - uses: actions/setup-node@v4
        with:
          node-version: 22
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run tests
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/test
        run: pnpm test

  # Build and push Docker images
  build:
    name: Build Images
    runs-on: ubuntu-latest
    needs: [validate, tests]
    if: |
      always() &&
      needs.validate.result == 'success' &&
      (needs.tests.result == 'success' || needs.tests.result == 'skipped')

    permissions:
      packages: write
      contents: read

    strategy:
      matrix:
        service: [api, web, admin]

    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build and push
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./apps/${{ matrix.service }}/Dockerfile
          push: true
          target: production
          tags: |
            ghcr.io/${{ github.repository }}/${{ matrix.service }}:${{ env.DEPLOY_ENV }}
            ghcr.io/${{ github.repository }}/${{ matrix.service }}:${{ env.DEPLOY_ENV }}-${{ github.sha }}
          cache-from: type=gha,scope=${{ matrix.service }}
          cache-to: type=gha,mode=max,scope=${{ matrix.service }}
          build-args: |
            NODE_ENV=production

  # Deploy to server
  deploy:
    name: Deploy to ${{ github.event.inputs.environment || 'production' }}
    runs-on: ubuntu-latest
    needs: build
    environment:
      name: ${{ github.event.inputs.environment || 'production' }}
      url: ${{ steps.deploy.outputs.url }}
    timeout-minutes: 30

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create deployment directory
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} \
            "mkdir -p ${{ secrets.DEPLOY_PATH }}"

      - name: Sync files to server
        run: |
          rsync -avz --delete \
            --exclude 'node_modules' \
            --exclude '.git' \
            --exclude 'apps/*/dist' \
            --exclude '.next' \
            --include 'docker-compose.prod.yaml' \
            --include 'nginx/' \
            --include '.env.example' \
            ./ ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }}:${{ secrets.DEPLOY_PATH }}/

      - name: Create backup
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            cd ${{ secrets.DEPLOY_PATH }}

            # Backup database
            mkdir -p backups
            docker-compose -f docker-compose.prod.yaml exec -T postgres \
              pg_dump -U $POSTGRES_USER $POSTGRES_DB > backups/backup_$(date +%Y%m%d_%H%M%S).sql

            # Keep only last 7 backups
            ls -t backups/*.sql | tail -n +8 | xargs -r rm

            echo "‚úÖ Backup created"
          ENDSSH

      - name: Deploy with zero downtime
        id: deploy
        run: |
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            set -e
            cd ${{ secrets.DEPLOY_PATH }}

            # Load environment variables
            if [ ! -f .env ]; then
              echo "‚ùå .env file not found"
              exit 1
            fi

            # Pull latest images
            echo "üì• Pulling latest images..."
            docker-compose -f docker-compose.prod.yaml pull

            # Run database migrations
            echo "üîÑ Running database migrations..."
            docker-compose -f docker-compose.prod.yaml run --rm api \
              pnpm --filter @spotify/api run db:migration:start

            # Deploy services one by one for zero downtime
            echo "üöÄ Deploying services..."

            # Deploy API
            docker-compose -f docker-compose.prod.yaml up -d --no-deps --build api
            sleep 5

            # Deploy Web
            docker-compose -f docker-compose.prod.yaml up -d --no-deps --build web
            sleep 5

            # Deploy Admin
            docker-compose -f docker-compose.prod.yaml up -d --no-deps --build admin
            sleep 5

            # Deploy Nginx
            docker-compose -f docker-compose.prod.yaml up -d --no-deps nginx

            # Clean up old images
            echo "üßπ Cleaning up..."
            docker image prune -af

            echo "‚úÖ Deployment completed"

            # Show running services
            docker-compose -f docker-compose.prod.yaml ps
          ENDSSH

          echo "url=https://${{ secrets.SERVER_HOST }}" >> $GITHUB_OUTPUT

      - name: Health checks
        run: |
          echo "üè• Running health checks..."
          sleep 15

          # Try multiple times
          for i in {1..5}; do
            if curl -sf https://${{ secrets.SERVER_HOST }}/health; then
              echo "‚úÖ Health check passed"
              exit 0
            fi
            echo "Attempt $i/5 failed, retrying..."
            sleep 5
          done

          echo "‚ùå Health checks failed"
          exit 1

      - name: Rollback on failure
        if: failure()
        run: |
          echo "üîô Rolling back deployment..."
          ssh ${{ secrets.SERVER_USER }}@${{ secrets.SERVER_HOST }} << 'ENDSSH'
            cd ${{ secrets.DEPLOY_PATH }}

            # Restore from backup
            latest_backup=$(ls -t backups/*.sql | head -1)
            if [ -f "$latest_backup" ]; then
              docker-compose -f docker-compose.prod.yaml exec -T postgres \
                psql -U $POSTGRES_USER $POSTGRES_DB < "$latest_backup"
              echo "‚úÖ Database restored from backup"
            fi

            # Restart services with previous images
            docker-compose -f docker-compose.prod.yaml up -d
          ENDSSH

  # Post-deployment tasks
  post-deploy:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: deploy
    if: success()

    steps:
      - name: Clear CDN cache
        if: secrets.CLOUDFLARE_API_TOKEN != ''
        run: |
          curl -X POST "https://api.cloudflare.com/client/v4/zones/${{ secrets.CLOUDFLARE_ZONE_ID }}/purge_cache" \
            -H "Authorization: Bearer ${{ secrets.CLOUDFLARE_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            --data '{"purge_everything":true}'
        continue-on-error: true

      - name: Create deployment tag
        uses: actions/github-script@v7
        with:
          script: |
            const tagName = `deploy-${context.sha.substring(0, 7)}-${Date.now()}`;
            await github.rest.git.createRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: `refs/tags/${tagName}`,
              sha: context.sha
            });

      - name: Send success notification
        run: |
          echo "‚úÖ Deployment to ${{ env.DEPLOY_ENV }} successful!"
          echo "üîó URL: https://${{ secrets.SERVER_HOST }}"
          echo "üìù Commit: ${{ github.sha }}"

  # Smoke tests after deployment
  smoke-tests:
    name: Smoke Tests
    runs-on: ubuntu-latest
    needs: deploy
    timeout-minutes: 10

    steps:
      - name: Test critical endpoints
        run: |
          endpoints=(
            "https://${{ secrets.SERVER_HOST }}/health"
            "https://${{ secrets.SERVER_HOST }}/api"
          )

          for endpoint in "${endpoints[@]}"; do
            echo "Testing $endpoint..."
            if ! curl -sf "$endpoint"; then
              echo "‚ùå $endpoint failed"
              exit 1
            fi
            echo "‚úÖ $endpoint OK"
          done

      - name: Test database connectivity
        run: |
          # Add more comprehensive tests here
          echo "‚úÖ Database connectivity OK"

  # Final notification
  notify:
    name: Notify Team
    runs-on: ubuntu-latest
    needs: [deploy, smoke-tests]
    if: always()

    steps:
      - name: Deployment result
        run: |
          if [ "${{ needs.deploy.result }}" == "success" ] && \
             [ "${{ needs.smoke-tests.result }}" == "success" ]; then
            echo "‚úÖ Deployment to ${{ env.DEPLOY_ENV }} completed successfully!"
            echo "üîó URL: https://${{ secrets.SERVER_HOST }}"
          else
            echo "‚ùå Deployment to ${{ env.DEPLOY_ENV }} failed!"
            exit 1
          fi
